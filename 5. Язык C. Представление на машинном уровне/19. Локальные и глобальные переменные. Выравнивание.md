# Локальные и глобальные переменные. Выравнивание

#### **1. Локальные переменные**

**Определение:**

- Объявляются внутри функций или блоков кода (`{}`).
- Существуют только во время выполнения функции.

**Расположение в памяти:**

- Размещаются на **стеке** (Stack).
- Доступ к ним осуществляется через **указатель стека (SP)** и **базовый указатель (BP)**.

**Пример:**

```c
void func() {
    int x = 10;  // локальная переменная (в стеке)
    printf("%d", x);
}
```

**Машинный уровень (x86):**

```asm
func:
    push ebp          // сохраняем предыдущий базовый указатель
    mov ebp, esp      // устанавливаем новый базовый указатель
    sub esp, 4        // выделяем место под `x` (4 байта)
    mov dword [ebp-4], 10  // записываем 10 в `x`
    ...
    mov esp, ebp      // восстанавливаем указатель стека
    pop ebp           // восстанавливаем базовый указатель
    ret
```

**Особенности:**

- Быстрый доступ (по смещению от `ebp`).
- Автоматическое освобождение при выходе из функции.

Большинство примеров процедур, которые мы видели до сих пор, не требовали допол нительной памяти для размещения локальных переменных и все необходимое им храни ли в регистрах. Однако иногда локальные переменные приходится сохранять в памяти.  Вот несколько типичных примеров таких случаев:

```
• недостаточно регистров для хранения всех локальных переменных;
```


```
• к локальной переменной применяется оператор взятия адреса &, и, следователь но, должна иметься возможность сгенерировать этот адрес;
```


```
• некоторые локальные переменные могут быть массивами или структурами и,  как следствие, должны быть доступны по ссылкам на массив или структуру.
```



---

#### **2. Глобальные переменные**

**Определение:**

- Объявляются вне функций.
- Видимы во всей программе.
- Существуют на протяжении всей работы программы.

**Расположение в памяти:**

- Неинициализированные (`int x;`) → **сегмент BSS** (заполняется нулями).
- Инициализированные (`int y = 5;`) → **сегмент данных (Data)**.

**Пример:**

```c
int global_var = 100;  // глобальная переменная (в Data)

int main() {
    printf("%d", global_var);
    return 0;
}
```

**Машинный уровень (x86):**

```asm
section .data
global_var dd 100  // выделено в Data

main:
    push ebp
    mov ebp, esp
    mov eax, [global_var]  // обращение к глобальной переменной
    ...
```

**Особенности:**

- Медленнее, чем локальные (требуется обращение к памяти).
- Сохраняют значение между вызовами функций.

---

#### **3. Выравнивание данных (Alignment)**

**Определение:**

- Размещение данных в памяти по адресам, кратным их размеру (2, 4, 8 байт и т. д.).
- Необходимо для эффективного доступа к памяти (невыровненные данные могут обрабатываться медленнее или вызывать ошибки на некоторых архитектурах).

**Правила выравнивания:**

- `char` – 1 байт.
- `short` – 2 байта.
- `int`, `float` – 4 байта.
- `double`, `long long` – 8 байт.
- Структуры выравниваются по наибольшему полю.

**Пример:**

```c
struct Example {
    char a;      // 1 байт (+3 padding)
    int b;       // 4 байта
    short c;     // 2 байта (+2 padding)
};               // Итого: 12 байт (не 7!)
```

**Машинный уровень:**

```asm
section .data
example:
    db 1         // 'a' (1 байт)
    align 4      // выравнивание до 4 байт
    dd 42        // 'b' (4 байта)
    dw 10        // 'c' (2 байта)
    align 2      // выравнивание структуры
```

**Зачем нужно выравнивание?**

- Некоторые процессоры (например, x86) поддерживают невыровненный доступ, но с потерей производительности.
- ARM и RISC-V могут вызывать исключения при невыровненном доступе.
- Кэш-линии работают эффективнее с выровненными данными.

---

#### **4. Сравнение локальных и глобальных переменных**


| Характеристика        | Локальные переменные                     | Глобальные переменные          |
| ----------------------------------- | ----------------------------------------------------------- | -------------------------------------------------- |
| **Время жизни**           | Только в рамках функции                 | Вся программа                          |
| **Память**                    | Стек                                                    | Data/BSS                                           |
| **Скорость доступа** | Быстрее (через`ebp`)                            | Медленнее (прямой доступ)     |
| **Инициализация**      | Мусор (если не инициализированы) | 0 (BSS) / заданное значение (Data) |

---

#### **5. Вывод**

- **Локальные переменные** хранятся на стеке, работают быстро, но живут недолго.
- **Глобальные переменные** хранятся в сегменте данных, сохраняют значения, но доступ к ним медленнее.
- **Выравнивание** критически важно для производительности и корректной работы на некоторых архитектурах.
- Компилятор автоматически добавляет **padding** в структуры для соблюдения выравнивания.

Эти особенности помогают писать эффективный и переносимый код на C.
