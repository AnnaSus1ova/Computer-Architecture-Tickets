## **1. Процедуры (функции) на машинном уровне**

![1747333008836](images/21.Процедуры.СоглашениеовызовахвLinux.Рекурсия/1747333008836.png)

![1747332939102](images/21.Процедуры.СоглашениеовызовахвLinux.Рекурсия/1747332939102.png)

### **1.1. Основные понятия**

* **Процедура** — логически обособленный блок кода с:
  * Входными параметрами
  * Возвращаемым значением
  * Локальными переменными
  * Адресом возврата
* Стек вызовов (Call Stack):
  * LIFO-структура (Last In, First Out)
  * Хранит:
    * Адреса возврата
    * Параметры функций
    * Локальные переменные
    * Состояние регистров

## **2. Соглашение о вызовах в Linux (x86-64, System V ABI)**

#### **Общие положения**

Соглашение о вызовах (Calling Convention) — это набор правил, определяющих:

* Как передаются параметры в функции
* Как возвращаются результаты
* Какие регистры сохраняются/восстанавливаются
* Как распределяется стек

В Linux для архитектуры x86-64 используется **System V AMD64 ABI**.

### **2.1. Передача параметров**

Первые 6 параметров передаются через регистры:




| Параметр | Регистр | Назначение                           |
| ---------------- | -------------- | ---------------------------------------------- |
| 1                | `rdi`          | Целочисленные, указатели |
| 2                | `rsi`          | Целочисленные, указатели |
| 3                | `rdx`          | Целочисленные, указатели |
| 4                | `rcx`          | Целочисленные, указатели |
| 5                | `r8`           | Целочисленные, указатели |
| 6                | `r9`           | Целочисленные, указатели |

**Пример передачи параметров**:

**c**

```
void func(int a, int b, int c, int d, int e, int f, int g);
// a → rdi, b → rsi, c → rdx, d → rcx, e → r8, f → r9, g → стек
```

#### **Дополнительные параметры**

Параметры с 7-го и далее передаются через **стек** (справа налево):

**c**

```
void func(int a, int b, int c, int d, int e, int f, int g, int h);
// g → [rsp+8], h → [rsp+16] при вызове
```

#### **Плавающая точка**

Параметры типа `float`/`double` передаются через регистры `xmm0`-`xmm7`:

**c**

```
double func(double a, double b);
// a → xmm0, b → xmm1
```

### **2.2. Возвращаемое значение**




| Тип возврата           | Регистр                                     |
| --------------------------------- | -------------------------------------------------- |
| Целочисленные        | `rax`                                              |
| Указатели                | `rax`                                              |
| `float`/`double`                  | `xmm0`                                             |
| Большие структуры | Через скрытый параметр (`rdi`) |

**Пример**:

**c**

```
int sum(int a, int b) {
    return a + b;  // Результат в eax
}
```

### **2.3. Сохранение регистров**

#### **Caller-saved (вызывающая сторона сохраняет)**

Эти регистры могут быть изменены функцией:

* `rax` — возвращаемое значение
* `rcx`, `rdx`, `rsi`, `rdi` — параметры
* `r8-r11` — временные регистры

**Обязанность**: Если значение нужно сохранить — вызывающая функция должна сохранить его перед `call`.

#### **Callee-saved (вызываемая сторона сохраняет)**

Эти регистры должны быть восстановлены перед возвратом:

* `rbx`, `rbp`, `rsp` — базовые регистры
* `r12-r15` — дополнительные регистры

**Обязанность**: Если функция их использует — должна сохранить (обычно в прологе) и восстановить (в эпилоге).

### **3.1 Управление стеком**

#### **Выравнивание стека**

* Перед `call` стек должен быть **выровнен по 16 байтам**.
* После `push` (8 байт) часто требуется дополнительное выравнивание.

**Правило**: `rsp % 16 == 0` перед вызовом функции.

#### **Красная зона (Red Zone)**

* Область **128 байт ниже `rsp`**, которую можно использовать без изменения `rsp`.
* Доступна только в leaf-функциях (которые не вызывают другие функции).

* Перед `call` стек должен быть выровнен по 16 байтам.
* После `push` (8 байт) требуется дополнительное выравнивание.

### **4. Пример полного вызова функции**

**Исходный код на C**:

**c**

```
long func(int a, int b, long c, int d, int e, int f, int g, int h) {
    return a + b + c + d + e + f + g + h;
}
```

Ассемблер (x86-64):

**asm**

```
func:
    push rbp
    mov rbp, rsp
  
    ; Доступ к параметрам:
    ; a (edi), b (esi), c (rdx), d (ecx), e (r8d), f (r9d)
    ; g → [rbp+16], h → [rbp+24]
  
    movsxd rax, edi     ; a
    add rax, rsi        ; +b
    add rax, rdx        ; +c
    add rax, rcx        ; +d
    add rax, r8         ; +e
    add rax, r9         ; +f
    add rax, [rbp+16]   ; +g
    add rax, [rbp+24]   ; +h
  
    pop rbp
    ret
```


## **3. Рекурсия на машинном уровне**

Рекурсия — это процесс, при котором функция вызывает саму себя (прямая рекурсия) или вызывает другую функцию, которая в итоге вызывает исходную (косвенная рекурсия). Это мощный инструмент, который особенно полезен для задач, которые можно разбить на более мелкие подзадачи того же типа.

### **3.1. Компоненты рекурсивной функции**

Каждая рекурсивная функция должна содержать:

1. **Базовый случай (терминальное условие)** — условие выхода из рекурсии.
2. **Рекурсивный случай** — вызов функции с изменёнными параметрами.

**Пример (факториал):**

**c**

```
int factorial(int n) {
    // Базовый случай
    if (n <= 1) return 1;
  
    // Рекурсивный случай
    return n * factorial(n - 1);
}
```

### **3.2. Принцип работы**

* Каждый рекурсивный вызов создаёт **новый экземпляр функции** в стеке вызовов.
* При достижении базового случая начинается **"свёртывание"** (возврат значений).

### **3.3. Представление рекурсии на машинном уровне**

### **а) Стек вызовов**

Каждый вызов функции сохраняет в стеке:

* Адрес возврата
* Локальные переменные
* Параметры функции

**Структура стека для `factorial(3)`**:

```
| factorial(1) | <- вершина стека (базовый случай)
| factorial(2) |
| factorial(3) |
| main()       |
```

### **б) Ассемблерный код (x86-64)**

**asm**

```
factorial:
    push rbp            ; Пролог
    mov rbp, rsp
  
    cmp edi, 1          ; n <= 1?
    jg .Lrecursive
    mov eax, 1          ; Базовый случай: return 1
    jmp .Lreturn
  
.Lrecursive:
    mov eax, edi        ; eax = n
    sub edi, 1          ; n - 1
    call factorial      ; Рекурсивный вызов
    imul eax, edi       ; n * factorial(n-1)
  
.Lreturn:
    pop rbp             ; Эпилог
    ret
```

```### **3.3 Опасности рекурсии**

### **а) Переполнение стека**

* Происходит при слишком большой глубине рекурсии.
* Размер стека по умолчанию в Linux — 8 МБ.

**Пример опасного кода:**

**c**

```
void infinite_recursion() {
    infinite_recursion();  // Бесконечная рекурсия
}
```
### **б) Неэффективность**

* Накладные расходы на вызов функции.
* Избыточные вычисления (если нет мемоизации).

**Пример (Фибоначчи без оптимизации):**

**c**

```
int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);  // O(2^n) времени!
}
```
## **4. Анализ и отладка**

### **4.1. Команды GDB**

**sh**

```
disassemble function_name  # Просмотр ассемблерного кода
info registers            # Просмотр регистров
bt                        # Просмотр стека вызовов
```
### **4.2. Размер стека в Linux**

**sh**

```
ulimit -s  # Показать текущий размер стека
ulimit -s unlimited  # Снять ограничение (для тестов)
```
## **5. Ключевые отличия x86 и x86-64**


| Характеристика        | x86                                      | x86-64                                        |
| ----------------------------------- | ---------------------------------------- | --------------------------------------------- |
| **Размер регистров** | 32 бита                              | 64 бита                                   |
| **Параметры**              | Передаются через стек | Первые 6 — через регистры |
| **Caller-saved**                    | `eax`, `ecx`, `edx`                      | `rax`, `rcx`, `rdx`, `rsi`, `rdi`, `r8-r11`   |


```
