# **Оператор ветвления switch. Таблица переходов.**

#### **1. Оператор ветвления `switch`**

`switch` — это управляющая конструкция, позволяющая выбрать один из множества вариантов выполнения кода в зависимости от значения выражения.

**Синтаксис:**

**c**

```
switch (выражение) {
    case константа1:
        // код для константа1
        break;
    case константа2:
        // код для константа2
        break;
    ...
    default:
        // код, если ни один case не подошел
}
```

**Особенности:**

* `выражение` должно быть целочисленного типа (`int`, `char`, `enum`).
* `case`-метки должны быть константными выражениями.
* `break` предотвращает "проваливание" в следующий `case`.
* `default` выполняется, если ни один `case` не совпал (не обязателен).

#### **2. Реализация `switch` на машинном уровне**

Компилятор оптимизирует `switch` двумя основными способами:

##### **a) Последовательные сравнения (как if-else)**

* Используется, если `case`-меток мало или они разрознены.
* Генерируется цепочка сравнений и условных переходов.

**Пример на ассемблере (x86):**

**asm**

```
mov eax, [значение]  ; загружаем значение в регистр
cmp eax, 10          ; сравниваем с case 10
je case10            ; если равно, переходим на case10
cmp eax, 20          ; иначе сравниваем с case 20
je case20            ; если равно, переходим на case20
jmp default          ; иначе в default
```

##### **b) Таблица переходов (Jump Table)**

* Используется, если `case`-метки плотные (например, `1, 2, 3, ... N`).
* Создается массив адресов переходов, и значение `switch` используется как индекс в этом массиве.

**Пример на ассемблере (x86):**

**asm**

```
section .data
jump_table:
    dd case0   ; адрес перехода для case 0
    dd case1   ; адрес перехода для case 1
    dd case2   ; адрес перехода для case 2

section .text
mov eax, [значение]  ; загружаем значение
cmp eax, 2           ; проверяем границы
ja default           ; если значение > 2, переход в default
jmp [jump_table + eax * 4]  ; косвенный переход через таблицу
```

#### **4. Таблица переходов (Jump Table)**

* Это массив адресов, где каждый элемент соответствует адресу кода для определенного `case`.
* Позволяет выполнить переход за O(1)**, в отличие от цепочки `if-else` (**O(n)**).
* Эффективна при большом количестве `case` с близкими значениями.

**Пример в C:**

**c**

```
int x = 2;
switch (x) {
    case 0: printf("Zero"); break;
    case 1: printf("One"); break;
    case 2: printf("Two"); break;
    default: printf("Other");
}
```

**Соответствующая таблица переходов:**


| Индекс (`x`) | Адрес перехода |
| ------------------ | --------------------------- |
| 0                  | `case0`                     |
| 1                  | `case1`                     |
| 2                  | `case2`                     |

#### **5. Вывод**

* `switch` может компилироваться либо в последовательность `if-else`, либо в таблицу переходов.
* Таблица переходов эффективна при плотных значениях `case`.
* Отсутствие `break` приводит к "проваливанию" — выполнению кода следующего `case`.

Этот механизм позволяет оптимизировать выполнение программы на машинном уровне в зависимости от структуры `switch`.
